// UART Receiver with state output for waveform debugging
module uart_rx
  #(parameter CLKS_PER_BIT = 87)
  (
    input        i_Clock,
    input        i_Rx_Serial,
    output       o_Rx_DV,
    output [7:0] o_Rx_Byte,
    output [1:0] state // <-- Added state output
  );

  localparam S_IDLE  = 2'b00,
             S_START = 2'b01,
             S_DATA  = 2'b10,
             S_STOP  = 2'b11;

  reg [1:0]  state_reg = S_IDLE; // Internal state register
  reg [7:0]  clk_count = 0;
  reg [2:0]  bit_idx = 0;
  reg [7:0]  rx_byte = 0;
  reg        rx_dv = 0;
  reg        rx_data_r = 1'b1, rx_data = 1'b1;

  // Double-register incoming data for metastability
  always @(posedge i_Clock) begin
    rx_data_r <= i_Rx_Serial;//w_Tx_Serial
    rx_data   <= rx_data_r;
  end

  always @(posedge i_Clock) begin
    case (state_reg)
      S_IDLE: begin
        rx_dv     <= 0;
        clk_count <= 0;
        bit_idx   <= 0;
        if (rx_data == 0) //updated after 3 clock cycle after negedge of w_Tx_Serial
          state_reg <= S_START;
      end
      S_START: begin
        if (clk_count == (CLKS_PER_BIT-1)/2) begin
          if (rx_data == 0) begin  //continuously equal to 0 from previous situation
            clk_count <= 0;// same posedge with state_reg
            state_reg <= S_DATA;//non-blocking. 
          end else
            state_reg <= S_IDLE;
        end else
          clk_count <= clk_count + 1;//0, 1, 2, 3. 3 is satisified
      end
      S_DATA: begin
        if (clk_count == CLKS_PER_BIT-1) begin
          clk_count       <= 0;
          rx_byte[bit_idx]<= rx_data;
          if (bit_idx == 7) begin
            bit_idx <= 0;
            state_reg <= S_STOP;
          end else
            bit_idx <= bit_idx + 1;
        end else
          clk_count <= clk_count + 1;
      end
      S_STOP: begin
        if (clk_count == CLKS_PER_BIT-1) begin //optional
          rx_dv     <= 1;
          clk_count <= 0;
          state_reg <= S_IDLE;
        end else begin
          clk_count <= clk_count + 1;
          rx_dv     <= 0;
        end
      end
      default: state_reg <= S_IDLE;
    endcase
  end

  assign o_Rx_DV = rx_dv;
  assign o_Rx_Byte = rx_byte;
  assign state = state_reg; // <-- assign internal state to output
endmodule
